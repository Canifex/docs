# どこで何が動いている？クライアント VS サーバー

クライアントとサーバーの両方で動くフレームワークでは、「どこで何か動いているか」を知ることが困難になりがちです。To simplify things, we'll break down the different parts of app's and where they run.

## コントローラーとビュー

Voltでは、コントローラーとモデルとビューには、クライアント側とサーバー側の両方でアクセスすることができます。ただ、一般的には **コントローラー** と **ビュー** は通常クライアント側だけで動作します。将来的には、ロード時間の高速化のため、最初のページのリクエストではサーバー側でまず実行されるようになる予定です。

## もでる

モデルはクライアントとサーバーの両方で動きます。モデルが変更された場合、そのバリデーション/パーミッションの処理、変更が許可されたものであるかをチェックするために、まずクライアントサイドで実行されます。それが成功したら、変更はサーバーに通知され、サーバー側でモデルが再度読み込まれ、サーバー側に変更が反映されます。サーバー側でもバリデーションパーミッションの処理が実行され、それにパスすると、モデルは保存されて他のクライアントにも同期します。このことはモデルのコードはクライアントとサーバーのどちらでも動作する必要があるということを意味しています。

## タスク

タスクは興味深い機能です。サーバー側のコードをクライアント側から呼び出すことを意図しています。Voltの同期モデルによって、書いたアプリケーションのほとんどはクライアント側で動作します。クライアント側でコードが動作することで、高速なリロードやアクション間でのデータの共有が実現できます。しかし、クライアント側からサーバー側のコードを呼び出したい場合は多いでしょう。

- **セキュリティ**: あるデータはサーバー側で処理をして、クライアントには送信したくない場合。
- **帯域**: 最終的な結果は小さいが、大量のデータを処理する必要がある場合。
- **Opal非互換Gem**: GemによってはOpalがサポートしていないものもあります。タスクを経由すれば容易にアクセス可能です。

タスクはTaskインスタンスのすべてのメソッドに対して非同期のインターフェースを提供します。すべてのパブリックなタスクメソッドにアクセスするには…

## クライアントかサーバーのいずれかでコードを実行する

```Volt.server?```  と```Volt.client?``` を利用すれば、コードがサーバーとクライアントのどちらで動作しているか確認することができます。しかし時には、クライアント側ではコードを一切コンパイルしないようにしたい場合もあるでしょう。そのような場合には、Opalが提供している、コードをコンパイルしないようにするための方法を利用します。以下のようにします。:

```ruby
if RUBY_PLATFORM != 'opal'
  ...
end
```

上記の冴えた方法によって、完全にコードは取り除かれ、クライアントに送信されることはありません。ただ、この方法は```require```には効果がないことに注意してください。Opalはコンパイル時にrequireを実行するからです。
