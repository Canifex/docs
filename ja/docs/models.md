# モデル

多くのフレームワークでは、モデルというのはデータベースとの ORM で使われる単語ですが、Volt のモデルのコンセプトはそれとは少し異なっています。Volt において、モデルはデータを簡単に保存しておくために利用できるクラスを指します。モデルを作成するときには「Volt::Persistor (永続化機構)」を待たせることができます。それが、モデルのデータを保持しておく役割を果たします。Persistor を使わずに作成したモデルでは、データは単純にクラスのインスタンスに保存されます。どのようにモデルを使うのか、まず見てみましょう。

Volt には多くのモデルが組み込まれており、その1つに ```page``` モデルがあります。コントローラーで ```#page``` を呼び出すことでそのモデルにアクセスすることができます。

```ruby
page._name = 'Ryan'
page._name
# => 'Ryan'
```

モデルは、先頭がアンダースコアで始まるゲッター/セッターでアクセスすることのできる、属性を持ったハッシュのように振る舞います。「アンダースコア・メソッド」を実行した時は、属性が定義されていればその属性の値を、定義されていなければ```nil```を返します。メソッド名にアンダースコアをつけることは、通常のメソッドを呼び出した際に、もし綴り間違いなどがあった場合には、想定通りに```NoMethodError```が発生することを意味しています。フィールドはハッシュのように振る舞いますが、アクセスと代入については異なるシンタックスを使用します。

モデルは深いネストを構成すること可能です。もし深いネストが必要であれば、親のモデルに空のハッシュをアサインしておくか、もしくは```!```を付与することで、からのモデルを自動的に生成することができます。(これを「拡張」と呼びます)

```ruby
page._setting!._color = 'blue'
page._setting._color
# => 'blue'

page._setting
# => #<Volt::Model:70100138058800 path:[:setting] state:loaded {:color=>"blue"}>
```

Volt のモデルでは、複数形の名前を持ったプロパティは ```Volt::ArrayModel``` のインスタンスを返します。ArrayModel は通常のアレイと同じように振る舞います。要素の追加/削除は通常のアレイと同様のメソッド (```#<<```, ```push```, ```append```, ```delete```, ```delete_at```, etc...) で行うことができます。

```ruby
page._items
# #<Volt::ArrayModel:70303686333720 []>

page._items << {name: 'Item 1'}

page._items
# #<Volt::ArrayModel:70303686333720 [<Volt::Model:70303682055800 {:name=>"Item 1"}>]>

page._items.size
# => 1

page._items[0]
# => <Volt::Model:70303682055800 {:name=>"Item 1"}>
```
